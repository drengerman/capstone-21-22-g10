# -*- coding: utf-8 -*-
"""capstone_path_planning

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IsRNT0jMwWab9tZF_Pu-wKZ8Q_vwjBtc
"""

import numpy as np
from pandas import read_csv
import cv2
import matplotlib.pyplot as plt
import math
import csv

#Iterate through rows
#Is row completely clear?
#If so, just skip to the end
#If not, check the row above for obstacles and move to the space below the last free space
#Repeat above until reaching a safe row, then move back downwards

#Input CSV fed from obstacle detection module
file_name = "ObsMapNew.csv"
df = read_csv(file_name, header=None)
ar = df.values.astype('uint8')
print(ar)

#Function to find the endpoints of each row based on the obstacles
#Iterate through rows
#For each row, iterate through the elements
#Determine where the margins end, and set those to be the endpoints
def find_endings(input):
  endings = []
  width = np.shape(input)[1]

  for row in input:
    row_end = []
    in_left_margin = True
    in_right_margin = True
    left_end = -1
    right_end = -1

    index = 0
    for element in row:
      if element == 0 and in_left_margin:
        in_left_margin = False
        left_end = index
        break
      index += 1

    index = width - 1
    for element in reversed(row):
      if element == 0 and in_right_margin:
        in_right_margin = False
        right_end = index
        break
      index += -1

    row_end.append(left_end)
    row_end.append(right_end)

    endings.append(row_end)

  return endings

#Function to check if a row is completely clear
def check_row(row):
  outcome = True
  for element in row:
    if element != 0:
      outcome = False
      break
  return outcome

#Function to pass through an empty row
def pass_through(direction, location, sequence, width):
  if direction == "right":
    location = [location[0], width - 1]
    sequence.append(location)
  elif direction == "left":
    location = [location[0], 0]
    #print(location)
    sequence.append(location)
  else:
    print("ERROR DURING PASS THROUGH: Direction is neither left or right.")
  return

#Function to translate a series of points to a series of waypoints in real-space, using the camera's FOV and altitude
def translate(sequence, altitude, row_size, col_size):
  vert_radius = math.tan(1*0.5)*altitude # 57.7 degrees in radians is just about 1
  hor_radius = math.tan(1.27*0.5)*altitude # 72.9 degrees in radians is just about 1.27
  pixel_size_h = hor_radius * 2 / row_size
  pixel_size_v = vert_radius * 2 /col_size
  pixel_size = pixel_size_h
  origin = [-hor_radius + 0.17, vert_radius - 0.1]
  print("ORIGIN: " + str(origin))
  new_sequence = []

  for element in sequence:
    new_sequence.append([round(origin[0] + pixel_size * element[1], 3), round(origin[1] - pixel_size * element[0], 3)])

  return new_sequence

test_empty = [[0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0]]
test_basic = [[0,0,0,0,-1], [0,-1,0,0,0], [0,0,0,0,0], [0,0,-1,0,0], [0,0,0,0,0]]
test_hourglass = [[0,0,0,0,0], [0,-1,-1,-1,0], [0,0,-1,0,0], [0,-1,-1,-1,0], [0,0,0,0,0]]
test_double = [[0,0,0,0,0], [0,-1,0,-1,0], [0,0,0,0,0], [0,0,-1,0,0], [0,0,0,0,0]]
test_diamond = [[0,0,0,0,0], [0,0,-1,0,0], [0,-1,-1,-1,0], [0,0,-1,0,0], [0,0,0,0,0]]

altitude = 2
USE_CSV = True
OBJ_THRESH = 15
ROW_SKIP = 1

start = [0,0] #Starting location
direction = "right" #Starting direction
location = start #Same as starting location
sequence = [] #Empty list of locations visited
sequence.append(location) #Add the starting location
last_safe_row = -1
safe_cols = []

input = test_basic #Input to run on
input = np.array(input)

resize_factor = 0.0833 # 1/12th original size
width = np.shape(input)[1] #The width of the image
height = np.shape(input)[0]

if USE_CSV:
  input = ar
  width = np.shape(input)[1] #The width of the image
  height = np.shape(input)[0]
  #width = int(width * resize_factor)
  #height = int(height * resize_factor)
  width = 16 # 16 default
  height = 12 # 12 default
  dim = (width, height)

  input = cv2.resize(input, dim, interpolation=cv2.INTER_AREA)
  print(input)
  plt.imshow(input)

endings = find_endings(input)

#Check which columns are safe
for j in range(0, width-1):
  safe = True
  for i in range(0, height-1, ROW_SKIP):
    if(input[i][j] >= OBJ_THRESH):
      safe = False
  if(safe):
    safe_cols.append(j)

counter = -1
#Iterate through rows of the image
for row_i in range(0, height, ROW_SKIP):
  row = input[row_i]
  counter += 1
  if(counter >= height - 1):
    break
  print(counter)
  safe = check_row(row) #Check if the row is safe (ie: no obstacles at all)

  if(safe): #If safe...
    pass_through(direction, location, sequence, width) #Pass through it
    location = sequence[-1] #Update location
    last_safe_row = location[0]

  else: #If not safe...
    pseudo_safe = True
    for space in range(endings[counter][0], endings[counter][1]):
      if row[space] >= OBJ_THRESH:
        pseudo_safe = False
    if pseudo_safe:
      last_safe_row = location[0]

    done = False
    unsafe_row = location[0]
    while(not done): #Repeat the following until we're at the end of the row
      #Move to the last safe tile before the obstacle
      spot = location[1]
      at_obstacle = False
      if(direction == "right"): #Move right to the next safe tile
        for i in range(location[1], width):
          if(row[i] >= OBJ_THRESH):
            location = [location[0], i - 1]
            if(i == endings[counter][1]):
              done = True
              location = [location[0], endings[counter][1]]
              break
            break
          elif(i == endings[counter][1]):
            done = True
            location = [location[0], endings[counter][1]]
            break
      elif(direction == "left"): #Move left to the next safe tile
        for i in range(location[1], -1, -1):
          if(row[i] >= OBJ_THRESH):
            location = [location[0], i + 1]
            if(i == endings[counter][0]):
              done = True
              location = [location[0], endings[counter][0]]
              break
            break
          elif(i == endings[counter][0]):
            done = True
            location = [location[0], endings[counter][0]]
            break
      else:
        print("ERROR DURING OBSTACLE TRAVEL: Direction is neither left or right.")
      sequence.append(location)
      if(not done):
        
        
        #Back up
        current_col = location[1]
        pseudo_col_safe = True
        for i in range(counter, last_safe_row, -1):
          if input[i][current_col] >= OBJ_THRESH:
            pseudo_col_safe = False

        if not pseudo_col_safe:
          check_last_col = -1
          good_col = -1
          for col in safe_cols:
            if(direction == "right"):
              if(col >= current_col):
                good_col = check_last_col
                break
            elif(direction == "left"):
              if(col >= current_col):
                good_col = col
                break
            else:
              print("ERROR DURING BACKING UP: Direction is neither left or right.")
            check_last_col = col
          location = [location[0], good_col]
          sequence.append(location)

        
        #Move up to the nearest safe row
        pseudo_safe_row = True
        pseudo_safe_row_loc = -1
        for i in range(row_i, last_safe_row-1, -1):
          pseudo_safe_row = True
          if direction == "right":
            for j in range(location[1], endings[i][1] + 1):
              if input[i][j] >= OBJ_THRESH:
                pseudo_safe_row = False
                break
          elif direction == "left":
            for j in range(location[1], endings[i][0]-1, -1):
              if input[i][j] >= OBJ_THRESH:
                pseudo_safe_row = False
                break
          if pseudo_safe_row:
            pseudo_safe_row_loc = i
            break

        if pseudo_safe_row:
          location = [pseudo_safe_row_loc, location[1]]
        else:
          location = [last_safe_row, location[1]]
        sequence.append(location)
        #Find the next safe tile in the row we care about
        checker = location[1]
        if(direction == "right"):
          while(row[checker] < OBJ_THRESH):
            checker = checker + 1
        elif(direction == "left"):
          while(row[checker] < OBJ_THRESH):
            checker = checker - 1
        while(row[checker] >= OBJ_THRESH):
          if(direction == "right"):
            checker = checker + 1
          elif(direction == "left"):
            checker = checker - 1
          else:
            print("ERROR DURING OBSTACLE CHECK: Direction is neither left or right.")
        #Move across to the next safe tile in the row below
        location = [location[0], checker]
        sequence.append(location)


        #Overshoot
        current_col = location[1]
        pseudo_col_safe = True
        for i in range(location[0], row_i+1):
          if input[i][current_col] >= OBJ_THRESH:
            pseudo_col_safe = False
        
        if not pseudo_col_safe:
          check_last_col = -1
          good_col = -1
          for col in safe_cols:
            if(direction == "right"):
              if(col >= current_col):
                good_col = check_last_col
                break
            elif(direction == "left"):
              if(col >= current_col):
                good_col = col
                break
            else:
              print("ERROR DURING OVERSHOOTING UP: Direction is neither left or right.")
            check_last_col = col
          location = [location[0], good_col]
        

        #Move back down to the row
        location = [unsafe_row, checker]
        sequence.append(location)
    pass

  #Now that we are at the end of the row...
  location = [location[0] + ROW_SKIP, location[1]] #Move to next row
  sequence.append(location) #Append that location to the sequence
  if(direction == "right"): #Swap the directions
    direction = "left"
  elif(direction == "left"): #Swap the directions
    direction = "right"
  else:
    print("ERROR ERROR DURING END OF ROW: Direction is neither left or right.")

print("PRE-FINAL SEQUENCE: " + str(sequence))

final = translate(sequence, altitude, width, height)
print(final)

header = ["xy"]
with open("output.csv", "w", newline="") as f:
  writer = csv.writer(f)
  writer.writerows(header)
  writer.writerows(final)

import matplotlib.pyplot as plt

plt.plot(*zip(*final))

import matplotlib.pyplot as plt

for i in sequence:
  i.reverse()

plt.imshow(input)
plt.plot(*zip(*sequence))

import matplotlib.pyplot as plt
import matplotlib.image as mpimg

shift_sequence = sequence
for i in range(len(shift_sequence)):
  shift_sequence[i][0] = shift_sequence[i][0]
  shift_sequence[i][1] = shift_sequence[i][1]

scaled_sequence = [[j * 20 for j in i] for i in shift_sequence]

plt.imshow(mpimg.imread('200cmsnap.png'))
plt.plot(*zip(*scaled_sequence))